
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>estimatePrice</title><meta name="generator" content="MATLAB 9.8"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2020-12-04"><meta name="DC.source" content="estimatePrice.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }
span.typesection { color:#A0522D }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><pre class="codeinput">clc
clear
close <span class="string">all</span>
format <span class="string">longG</span>

<span class="comment">%define your test data here:</span>
data_to_estimate = [45 1978 1 1 0.2 0.3;
                    56 2000 2 2 0.6 1.6;
                    72 2016 3 6 1.4 0.65];

<span class="comment">% Expected prices for this dataset (from data.xls) - 202000, 209000 and 225000</span>
<span class="comment">% Results of the estimations using the function - 204164, 205261 and 228614</span>
test_data = [36,1962,1,2,-0.0949103322753609,1.72061853694211;
             39,1961,1,3,-0.0691434203045192,1.72883298748516;
             48,1974,1,1,0.0268755476418518,0.111864124433479];

<span class="comment">%call the function here:</span>
estimated_price(1,:) = estimate_price(data_to_estimate(1,:));
estimated_price(2,:) = estimate_price(data_to_estimate(2,:));
estimated_price(3,:) = estimate_price(data_to_estimate(3,:));

<span class="comment">% data_to_estimate = [estimated_price data_to_estimate];</span>
<span class="comment">% writematrix(data_to_estimate,'Estimation.xlsx','Sheet','MyNewSheet');</span>

<span class="comment">% Estimation function definition</span>
<span class="keyword">function</span> price_house = estimate_price(house_params)

    data = readtable(<span class="string">'data2.xlsx'</span>);
    data = table2array(data);

    columnNames = [<span class="string">"price"</span>, <span class="string">"area"</span>, <span class="string">"year"</span>, <span class="string">"roomsNo"</span>, <span class="string">"floor"</span>, <span class="string">"X"</span>, <span class="string">"Y"</span>, <span class="string">"distance"</span>];
    price = data(:,1);
    area = data(:,2);
    year = data(:,3);
    roomsNo = data(:,4);
    floor = data(:,5);
    X = data(:,6);
    Y = data(:,7);

    X_downtown = 1.43;
    Y_downtown = 0.63;
    P_downtown = [X_downtown, Y_downtown];

    <span class="comment">% in this loop we do feature extraction of the location of the house for better price estimation</span>
    <span class="comment">% here we use the vector length to find the distance from the downtown</span>
    distance = zeros (length(data(:,1)),1);
    <span class="keyword">for</span> i=1:length(data(:,1))
        distance(i) = sqrt((X_downtown - data(i,6))^2 + (Y_downtown - data(i,7))^2);
    <span class="keyword">end</span>

    <span class="comment">%adding the distance to downtown column</span>
    data = [data distance];
    distance = data(:,8);

    <span class="comment">% checking the correlation of the price to parameters</span>
    t = -20:20;
    figure
    <span class="keyword">for</span> i=2:length(columnNames)
        subplot(3,3,i-1)
        r = xcorr(data(:,i), price, 20,<span class="string">'coeff'</span>);
        stem(t, r);
        title(columnNames(i) + <span class="string">' to price correlation'</span>)
        ylabel(<span class="string">'correlation'</span>);
        xlabel(<span class="string">'lags'</span>)
        grid <span class="string">on</span>
    <span class="keyword">end</span>
    <span class="comment">% all features seem to be relevant</span>

    <span class="comment">% splitting data into two datasets, 75% training and 25% validation</span>
    <span class="comment">% splitting code based on the solutions for one of the assignments</span>
    idx_v = 1:4:length(price);
    k = 0;
    idx_t = zeros();
    <span class="keyword">for</span> i = 1:length(price)
         tempIdx = find(idx_v == i,1);
         <span class="keyword">if</span> isempty(tempIdx)
             k = k+1;
             idx_t(k) = i;
         <span class="keyword">end</span>
    <span class="keyword">end</span>
    [data_t] = [price(idx_t), area(idx_t), year(idx_t), roomsNo(idx_t), floor(idx_t), X(idx_t), Y(idx_t), distance(idx_t)];
    [data_v] = [price(idx_v), area(idx_v), year(idx_v), roomsNo(idx_v), floor(idx_v), X(idx_v), Y(idx_v), distance(idx_v)];


    <span class="comment">% calculating the parameters of the linear regression</span>
    <span class="comment">%(excluding the coordinates of the house and including the distance to the city center)</span>
    inputX = data_t(:,[2 3 4 5 8]);
    inputX = [ones(length(inputX),1)  inputX];
    outputY = data_t(:,1);
    theta = (inputX' * inputX) \ inputX' * outputY; <span class="comment">%theta = (xT*x)-1 * xT * Y</span>
    display(theta)

    <span class="comment">% Calculating SSE for test data</span>
    estimatedPrice = zeros(length(data_t(:,1)),1);
    <span class="keyword">for</span> i=1:length(data_t(:,1))
        estimatedPrice(i)= theta(1) + data_t(i,2) * theta(2) + data_t(i,3) * theta(3) + data_t(i,4) * theta(4) + data_t(i,5) * theta(5)  + data_t(i,8) * theta(6);
    <span class="keyword">end</span>
    estimated_data_t = [estimatedPrice data_t(:,2:6)];
    SSE_t = 0;
    SST_t = 0;
    <span class="keyword">for</span> i=1:length(estimated_data_t(:,1))
        SSE_t = SSE_t + (estimated_data_t(i,1) - data_t(i,1))^2;
        SST_t = SST_t + (estimated_data_t(i,1) - mean(data_t(:,1)))^2;
    <span class="keyword">end</span>
    R_squared_t = 1 - SSE_t/SST_t;
    display(SSE_t)
    display(R_squared_t)

    <span class="comment">% Calculating SSE for validation data</span>
    estimatedPrice = zeros(length(data_v(:,1)),1);
    <span class="keyword">for</span> i=1:length(data_v(:,1))
        estimatedPrice(i)= theta(1) + data_v(i,2) * theta(2) + data_v(i,3) * theta(3) + data_v(i,4) * theta(4) + data_v(i,5) * theta(5)  + data_v(i,8) * theta(6);
    <span class="keyword">end</span>
    estimated_data_v = [estimatedPrice data_v(:,2:6)];
    SSE_v = 0;
    SST_v = 0;
    <span class="keyword">for</span> i=1:length(estimated_data_v(:,1))
        SSE_v = SSE_v + (estimated_data_v(i,1) - data_v(i,1))^2;
        SST_v = SST_v + (estimated_data_v(i,1) - mean(data_v(:,1)))^2;
    <span class="keyword">end</span>
    R_squared_v = 1 - SSE_v/SST_v;
    display(SSE_v)
    display(R_squared_v)

    <span class="comment">% preprocessing the input data [house_params],</span>
    <span class="comment">% measuring its distance to Kamppi</span>
    distance_1 = zeros (length(house_params(:,1)),1);
    <span class="keyword">for</span> i=1:length(house_params(:,1))
        distance_1(i) = sqrt((X_downtown - house_params(i,5))^2 + (Y_downtown - house_params(i,6))^2);
    <span class="keyword">end</span>
    house_params = [house_params distance_1];

    <span class="comment">%estimating the price y = k1+k2x1+k3x2 ...</span>
    <span class="comment">%X and Y coordinates are ignored and the distance is used instead</span>
    price_house = theta(1) + house_params(1) * theta(2) + house_params(2) * theta(3) + house_params(3) * theta(4) + house_params(4) * theta(5)  + house_params(7) * theta(6);
    display(price_house)
    <span class="comment">%plotting of the estimated data along with the original dataset</span>
    figure
    <span class="keyword">for</span> i=2:length(columnNames)
        subplot(3,3,i-1)
        hold <span class="string">on</span>
        scatter(data(:,i), price, <span class="string">'b'</span>)
        scatter(house_params(:,i-1), price_house,<span class="string">'filled'</span>, <span class="string">'r'</span>)
        hold <span class="string">off</span>
        title(<span class="string">'Estimated '</span> + columnNames(i) + <span class="string">' to price ratio'</span>)
        ylabel(columnNames(1));
        xlabel(columnNames(i))
        grid <span class="string">on</span>
    <span class="keyword">end</span>

    <span class="comment">% attempt to minimize cost function</span>

<span class="comment">%     costFunction = @(x) sum((y - (x(1) + house_params(1) * x(2) + house_params(2) * x(3) + house_params(3) * x(4) + house_params(4) * x(5)  + house_params(5) * x(6) + house_params(6) * x(7)))^2);</span>
<span class="comment">%     x0 = ones(7,1);</span>
<span class="comment">%     [x,fval] = fminsearch(costFunction,x0);</span>
<span class="comment">%     thetaMin = [x(1), x(2), x(3), x(4), x(5), x(6), x(7)];</span>
<span class="comment">%     display(thetaMin)</span>
<span class="comment">%</span>
<span class="keyword">end</span>
</pre><pre class="codeoutput">Warning: Column headers from the file were modified to make them valid MATLAB
identifiers before creating variable names for the table. The original column
headers are saved in the VariableDescriptions property.
Set 'PreserveVariableNames' to true to use the original column headers as table
variable names. 

theta =

         -1502795.62569074
          436.755598271644
          883.833944873516
          568.098118302894
          293.254850524371
         -23469.2233871528


SSE_t =

          8929292747.91828


R_squared_t =

         0.928984355228418


SSE_v =

          3349058458.69207


R_squared_v =

         0.917829708990228


price_house =

          236055.236909125

Warning: Column headers from the file were modified to make them valid MATLAB
identifiers before creating variable names for the table. The original column
headers are saved in the VariableDescriptions property.
Set 'PreserveVariableNames' to true to use the original column headers as table
variable names. 

theta =

         -1502795.62569074
          436.755598271644
          883.833944873516
          568.098118302894
          293.254850524371
         -23469.2233871528


SSE_t =

          8929292747.91828


R_squared_t =

         0.928984355228418


SSE_v =

          3349058458.69207


R_squared_v =

         0.917829708990228


price_house =

          261091.623217124

Warning: Column headers from the file were modified to make them valid MATLAB
identifiers before creating variable names for the table. The original column
headers are saved in the VariableDescriptions property.
Set 'PreserveVariableNames' to true to use the original column headers as table
variable names. 

theta =

         -1502795.62569074
          436.755598271644
          883.833944873516
          568.098118302894
          293.254850524371
         -23469.2233871528


SSE_t =

          8929292747.91828


R_squared_t =

         0.928984355228418


SSE_v =

          3349058458.69207


R_squared_v =

         0.917829708990228


price_house =

          313077.638824706

</pre><img vspace="5" hspace="5" src="estimatePrice_01.png" alt=""> <img vspace="5" hspace="5" src="estimatePrice_02.png" alt=""> <img vspace="5" hspace="5" src="estimatePrice_03.png" alt=""> <img vspace="5" hspace="5" src="estimatePrice_04.png" alt=""> <img vspace="5" hspace="5" src="estimatePrice_05.png" alt=""> <img vspace="5" hspace="5" src="estimatePrice_06.png" alt=""> <p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2020a</a><br></p></div><!--
##### SOURCE BEGIN #####
clc
clear
close all
format longG

%define your test data here: 
data_to_estimate = [45 1978 1 1 0.2 0.3; 
                    56 2000 2 2 0.6 1.6;
                    72 2016 3 6 1.4 0.65];

% Expected prices for this dataset (from data.xls) - 202000, 209000 and 225000
% Results of the estimations using the function - 204164, 205261 and 228614 
test_data = [36,1962,1,2,-0.0949103322753609,1.72061853694211;
             39,1961,1,3,-0.0691434203045192,1.72883298748516;
             48,1974,1,1,0.0268755476418518,0.111864124433479];    
           
%call the function here: 
estimated_price(1,:) = estimate_price(data_to_estimate(1,:));
estimated_price(2,:) = estimate_price(data_to_estimate(2,:));
estimated_price(3,:) = estimate_price(data_to_estimate(3,:));

% data_to_estimate = [estimated_price data_to_estimate];
% writematrix(data_to_estimate,'Estimation.xlsx','Sheet','MyNewSheet');

% Estimation function definition 
function price_house = estimate_price(house_params)

    data = readtable('data2.xlsx');
    data = table2array(data);

    columnNames = ["price", "area", "year", "roomsNo", "floor", "X", "Y", "distance"];
    price = data(:,1);
    area = data(:,2);
    year = data(:,3);
    roomsNo = data(:,4);
    floor = data(:,5);
    X = data(:,6);
    Y = data(:,7);

    X_downtown = 1.43;
    Y_downtown = 0.63;
    P_downtown = [X_downtown, Y_downtown]; 
    
    % in this loop we do feature extraction of the location of the house for better price estimation 
    % here we use the vector length to find the distance from the downtown 
    distance = zeros (length(data(:,1)),1);
    for i=1:length(data(:,1))
        distance(i) = sqrt((X_downtown - data(i,6))^2 + (Y_downtown - data(i,7))^2);
    end
    
    %adding the distance to downtown column
    data = [data distance];
    distance = data(:,8);
            
    % checking the correlation of the price to parameters 
    t = -20:20;
    figure
    for i=2:length(columnNames)
        subplot(3,3,i-1)
        r = xcorr(data(:,i), price, 20,'coeff');
        stem(t, r);
        title(columnNames(i) + ' to price correlation')
        ylabel('correlation');
        xlabel('lags') 
        grid on
    end
    % all features seem to be relevant 
    
    % splitting data into two datasets, 75% training and 25% validation
    % splitting code based on the solutions for one of the assignments
    idx_v = 1:4:length(price);
    k = 0;
    idx_t = zeros();
    for i = 1:length(price)
         tempIdx = find(idx_v == i,1);
         if isempty(tempIdx)
             k = k+1;
             idx_t(k) = i;
         end
    end
    [data_t] = [price(idx_t), area(idx_t), year(idx_t), roomsNo(idx_t), floor(idx_t), X(idx_t), Y(idx_t), distance(idx_t)];
    [data_v] = [price(idx_v), area(idx_v), year(idx_v), roomsNo(idx_v), floor(idx_v), X(idx_v), Y(idx_v), distance(idx_v)];


    % calculating the parameters of the linear regression 
    %(excluding the coordinates of the house and including the distance to the city center)
    inputX = data_t(:,[2 3 4 5 8]);
    inputX = [ones(length(inputX),1)  inputX];
    outputY = data_t(:,1);
    theta = (inputX' * inputX) \ inputX' * outputY; %theta = (xT*x)-1 * xT * Y
    display(theta)
    
    % Calculating SSE for test data
    estimatedPrice = zeros(length(data_t(:,1)),1);
    for i=1:length(data_t(:,1))
        estimatedPrice(i)= theta(1) + data_t(i,2) * theta(2) + data_t(i,3) * theta(3) + data_t(i,4) * theta(4) + data_t(i,5) * theta(5)  + data_t(i,8) * theta(6); 
    end
    estimated_data_t = [estimatedPrice data_t(:,2:6)];
    SSE_t = 0;
    SST_t = 0;
    for i=1:length(estimated_data_t(:,1))
        SSE_t = SSE_t + (estimated_data_t(i,1) - data_t(i,1))^2;
        SST_t = SST_t + (estimated_data_t(i,1) - mean(data_t(:,1)))^2;
    end
    R_squared_t = 1 - SSE_t/SST_t;
    display(SSE_t)
    display(R_squared_t)
    
    % Calculating SSE for validation data
    estimatedPrice = zeros(length(data_v(:,1)),1);
    for i=1:length(data_v(:,1))
        estimatedPrice(i)= theta(1) + data_v(i,2) * theta(2) + data_v(i,3) * theta(3) + data_v(i,4) * theta(4) + data_v(i,5) * theta(5)  + data_v(i,8) * theta(6); 
    end
    estimated_data_v = [estimatedPrice data_v(:,2:6)];
    SSE_v = 0;
    SST_v = 0;
    for i=1:length(estimated_data_v(:,1))
        SSE_v = SSE_v + (estimated_data_v(i,1) - data_v(i,1))^2;
        SST_v = SST_v + (estimated_data_v(i,1) - mean(data_v(:,1)))^2;
    end
    R_squared_v = 1 - SSE_v/SST_v;
    display(SSE_v)
    display(R_squared_v)
    
    % preprocessing the input data [house_params], 
    % measuring its distance to Kamppi
    distance_1 = zeros (length(house_params(:,1)),1);
    for i=1:length(house_params(:,1))
        distance_1(i) = sqrt((X_downtown - house_params(i,5))^2 + (Y_downtown - house_params(i,6))^2);
    end
    house_params = [house_params distance_1];
    
    %estimating the price y = k1+k2x1+k3x2 ...
    %X and Y coordinates are ignored and the distance is used instead
    price_house = theta(1) + house_params(1) * theta(2) + house_params(2) * theta(3) + house_params(3) * theta(4) + house_params(4) * theta(5)  + house_params(7) * theta(6);
    display(price_house)
    %plotting of the estimated data along with the original dataset
    figure
    for i=2:length(columnNames)
        subplot(3,3,i-1)
        hold on
        scatter(data(:,i), price, 'b')
        scatter(house_params(:,i-1), price_house,'filled', 'r')
        hold off
        title('Estimated ' + columnNames(i) + ' to price ratio')
        ylabel(columnNames(1));
        xlabel(columnNames(i)) 
        grid on
    end
    
    % attempt to minimize cost function 

%     costFunction = @(x) sum((y - (x(1) + house_params(1) * x(2) + house_params(2) * x(3) + house_params(3) * x(4) + house_params(4) * x(5)  + house_params(5) * x(6) + house_params(6) * x(7)))^2);
%     x0 = ones(7,1);
%     [x,fval] = fminsearch(costFunction,x0);
%     thetaMin = [x(1), x(2), x(3), x(4), x(5), x(6), x(7)];
%     display(thetaMin)
%     
end
##### SOURCE END #####
--></body></html>